<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Explained - Calendar Puzzle DSA</title>
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- Highlight.js for syntax highlighting (local files) -->
    <link rel="stylesheet" href="../atom-one-dark.min.css">
    <script src="../highlight.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 3em;
            margin-bottom: 10px;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: #666;
            font-size: 1.2em;
            margin-bottom: 30px;
        }

        .back-btn {
            display: inline-block;
            padding: 12px 24px;
            background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);
            color: white;
            text-decoration: none;
            border-radius: 10px;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .back-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 210, 255, 0.4);
        }

        h2 {
            color: #00d2ff;
            font-size: 2em;
            margin-top: 40px;
            margin-bottom: 20px;
            border-bottom: 3px solid #00d2ff;
            padding-bottom: 10px;
        }

        h3 {
            color: #3a7bd5;
            font-size: 1.5em;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        p {
            line-height: 1.8;
            margin-bottom: 15px;
            font-size: 1.1em;
            color: #444;
        }

        .highlight {
            background: linear-gradient(120deg, #a8edea 0%, #fed6e3 100%);
            padding: 25px 30px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 6px solid #00d2ff;
            border: 3px solid rgba(0, 210, 255, 0.5);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        }

        .highlight strong {
            color: #1e3799;
            font-size: 1.15em;
            font-weight: 700;
        }

        .highlight p {
            color: #2c3e50;
            font-size: 1.05em;
            line-height: 1.7;
        }

        code {
            background: #282c34;
            color: #abb2bf;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 0.95em;
        }

        pre {
            background: #282c34;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #00d2ff;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        pre code {
            background: none;
            padding: 0;
            font-family: 'Fira Code', 'Courier New', monospace;
        }

        /* Highlight.js custom tweaks */
        .hljs {
            background: #282c34;
            padding: 0;
        }

        .hljs-comment {
            color: #5c6370;
            font-style: italic;
        }

        .hljs-keyword {
            color: #c678dd;
        }

        .hljs-function {
            color: #61afef;
        }

        .hljs-string {
            color: #98c379;
        }

        .hljs-number {
            color: #d19a66;
        }

        .complexity-box {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            padding: 25px 30px;
            border-radius: 12px;
            margin: 25px 0;
            border: 3px solid rgba(0, 210, 255, 0.5);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        }

        .complexity-box h4 {
            margin-bottom: 15px;
            color: #1e3799;
            font-size: 1.3em;
            font-weight: 700;
        }

        .complexity-box p,
        .complexity-box ul,
        .complexity-box li {
            color: #2c3e50;
            font-size: 1.05em;
        }

        .complexity-box strong {
            color: #1e3799;
            font-weight: 700;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 20px;
        }

        li {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .github-link {
            display: inline-block;
            padding: 15px 30px;
            background: #24292e;
            color: white;
            text-decoration: none;
            border-radius: 10px;
            margin: 30px 0;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 1.1em;
        }

        .github-link:hover {
            background: #0366d6;
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(3, 102, 214, 0.4);
        }

        .step-number {
            display: inline-block;
            background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            text-align: center;
            line-height: 30px;
            margin-right: 10px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0, 210, 255, 0.3);
        }

        .visual-demo {
            background: linear-gradient(135deg, #1a1a1a 0%, #252525 100%);
            padding: 35px;
            border-radius: 15px;
            margin: 30px 0;
            border: 3px solid #00d2ff;
            box-shadow: 0 8px 25px rgba(0, 210, 255, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .visual-demo h4 {
            color: #00d2ff;
            margin-bottom: 25px;
            text-align: center;
            font-size: 1.4em;
            font-weight: 700;
            text-shadow: 0 2px 10px rgba(0, 210, 255, 0.5);
        }

        .visual-demo h5 {
            color: #ffffff;
            font-weight: 600;
        }

        .visual-demo p {
            color: #e0e0e0;
        }

        .grid-visual {
            display: inline-block;
            margin: 15px;
            vertical-align: top;
        }

        .grid-visual h5 {
            color: #fff;
            text-align: center;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .mini-grid {
            display: grid;
            gap: 3px;
            background: #2a2a2a;
            padding: 10px;
            border-radius: 8px;
            margin: 0 auto;
        }

        .mini-cell {
            width: 35px;
            height: 35px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            font-family: monospace;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mini-cell.empty {
            background: #3a3a3a;
            color: #888;
            border: 1px solid #2a2a2a;
        }

        .mini-cell.piece {
            background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(0, 210, 255, 0.4);
            border: 1px solid #00d2ff;
            font-weight: 900;
        }

        .mini-cell.invalid {
            background: linear-gradient(135deg, #ff4757 0%, #ff3838 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(255, 71, 87, 0.4);
            border: 1px solid #ff4757;
            font-weight: 900;
        }

        .mini-cell.valid {
            background: linear-gradient(135deg, #2ed573 0%, #26de81 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(46, 213, 115, 0.4);
            border: 1px solid #2ed573;
            font-weight: 900;
        }

        .arrow {
            display: inline-block;
            font-size: 2em;
            color: #00d2ff;
            margin: 0 15px;
            vertical-align: middle;
        }

        .explanation-box {
            background: linear-gradient(135deg, rgba(0, 210, 255, 0.15) 0%, rgba(58, 123, 213, 0.15) 100%);
            border-left: 5px solid #00d2ff;
            border: 2px solid rgba(0, 210, 255, 0.4);
            padding: 20px 25px;
            margin: 25px 0;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 210, 255, 0.2);
        }

        .explanation-box p {
            margin: 10px 0;
            color: #ffffff;
            font-size: 1.05em;
            line-height: 1.7;
        }

        .explanation-box strong {
            color: #00d2ff;
            font-weight: 700;
        }

        .explanation-box ul {
            color: #ffffff;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
                border-radius: 10px;
            }

            h1 {
                font-size: 2em;
            }

            h2 {
                font-size: 1.5em;
            }

            pre {
                font-size: 0.85em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="../" class="back-btn">‚Üê Back to Puzzle</a>
        
        <h1>üß† Algorithm Explained</h1>
        <p class="subtitle">Understanding the Data Structures & Algorithms Behind the Calendar Puzzle Solver</p>

        <!-- Problem Statement -->
        <h2>üìã The Problem</h2>
        <p>
            The <strong>Perpetual Calendar Puzzle</strong> is a constraint satisfaction problem where we must place 8 puzzle pieces 
            on a 7√ó7 board so that all cells are covered except for one month and one date.
        </p>
        
        <div class="highlight">
            <strong>Challenge:</strong> With 8 pieces, multiple rotations/flips per piece, and 43 valid board positions, 
            the search space is enormous! We need smart algorithms to find solutions efficiently.
        </div>

        <!-- Data Structures -->
        <h2>üóÇÔ∏è Data Structures Used</h2>

        <h3>1. 2D Array (Grid Representation)</h3>
        <p>The board is represented as a 7√ó7 matrix:</p>
        <pre><code class="language-javascript">const boardLayout = [
  ["JAN","FEB","MAR","APR","MAY","JUN", null],
  ["JUL","AUG","SEP","OCT","NOV","DEC", null],
  ["1","2","3","4","5","6","7"],
  ...
];

const grid = Array.from({ length: 7 }, () => Array(7).fill(0));
// 0 = empty, -1 = target (month/date), >0 = piece ID</code></pre>

        <h3>2. Bitmask (Efficient State Tracking)</h3>
        <p>Instead of using an array like <code>[true, false, true, ...]</code> to track which pieces are used, we use a single integer where each bit represents one piece. This is significantly faster and uses less memory.</p>
        
        <div class="visual-demo">
            <h4>Bitmask Example: Tracking 8 Pieces</h4>
            <div style="text-align: center; color: #e0e0e0;">
                <div style="margin: 20px 0;">
                    <h5 style="color: #00d2ff; margin-bottom: 15px;">Binary Representation</h5>
                    <div style="font-family: monospace; font-size: 1.3em; margin: 15px 0;">
                        <span style="color: #666;">Piece: </span>
                        <span style="color: #00d2ff;">7</span>
                        <span style="margin: 0 5px;">|</span>
                        <span style="color: #00d2ff;">6</span>
                        <span style="margin: 0 5px;">|</span>
                        <span style="color: #00d2ff;">5</span>
                        <span style="margin: 0 5px;">|</span>
                        <span style="color: #00d2ff;">4</span>
                        <span style="margin: 0 5px;">|</span>
                        <span style="color: #00d2ff;">3</span>
                        <span style="margin: 0 5px;">|</span>
                        <span style="color: #00d2ff;">2</span>
                        <span style="margin: 0 5px;">|</span>
                        <span style="color: #00d2ff;">1</span>
                        <span style="margin: 0 5px;">|</span>
                        <span style="color: #00d2ff;">0</span>
                    </div>
                    <div style="font-family: monospace; font-size: 1.3em; margin: 15px 0;">
                        <span style="color: #666;">Bits:  </span>
                        <span style="color: #2ed573;">1</span>
                        <span style="margin: 0 8px;">|</span>
                        <span style="color: #ff4757;">0</span>
                        <span style="margin: 0 8px;">|</span>
                        <span style="color: #2ed573;">1</span>
                        <span style="margin: 0 8px;">|</span>
                        <span style="color: #ff4757;">0</span>
                        <span style="margin: 0 8px;">|</span>
                        <span style="color: #2ed573;">1</span>
                        <span style="margin: 0 8px;">|</span>
                        <span style="color: #ff4757;">0</span>
                        <span style="margin: 0 8px;">|</span>
                        <span style="color: #2ed573;">1</span>
                        <span style="margin: 0 8px;">|</span>
                        <span style="color: #2ed573;">1</span>
                    </div>
                    <p style="color: #aaa; font-size: 0.9em; margin-top: 10px;">
                        Binary: <span style="color: #00d2ff;">10101011</span> = Decimal: <span style="color: #00d2ff;">171</span>
                    </p>
                    <p style="color: #2ed573; font-size: 0.95em; margin-top: 15px;">
                        <strong>Used pieces:</strong> 0, 1, 3, 5, 7 (green bits = 1)
                    </p>
                    <p style="color: #ff4757; font-size: 0.95em;">
                        <strong>Unused pieces:</strong> 2, 4, 6 (red bits = 0)
                    </p>
                </div>
            </div>
        </div>
        
        <pre><code class="language-javascript">// Each bit represents one piece (0 = unused, 1 = used)
const ALL_PIECES_MASK = (1 << 8) - 1;  // 11111111 in binary = 255

// Check if piece i is used: O(1) - Single CPU instruction!
if (usedMask & (1 << i)) { 
    /* piece i is used */ 
}

// Mark piece i as used: O(1) - Just flip one bit!
usedMask = usedMask | (1 << i);

// Example: Mark piece 3 as used
// Before: 10100011 (pieces 0,1,5,7 used)
// After:  10101011 (pieces 0,1,3,5,7 used)

// Compare to array approach (much slower):
// used[3] = true;  // Needs memory access, not just bit flip</code></pre>

        <div class="explanation-box">
            <p><strong>Why Bitmasks Are Faster:</strong></p>
            <p><strong>Memory:</strong> One integer (4-8 bytes) vs. array of 8 booleans (8+ bytes)</p>
            <p><strong>Operations:</strong> Bit operations are single CPU instructions (nanoseconds)</p>
            <p><strong>Cache Friendly:</strong> Everything fits in a single register</p>
            <p><strong>Comparison:</strong> Checking one integer is faster than iterating through an array</p>
            <p><strong>Real Impact:</strong> In our benchmarks, bitmask was 10x faster than boolean arrays for state tracking!</p>
        </div>

        <h3>3. Array of Coordinates (Piece Shapes)</h3>
        <p>Each piece is a list of relative coordinates:</p>
        <pre><code class="language-javascript">// L-shaped piece
[[0,0], [1,0], [2,0], [2,1], [2,2]]

// Represents:
// ‚ñà
// ‚ñà
// ‚ñà ‚ñà ‚ñà</code></pre>

        <!-- Algorithm -->
        <h2>‚öôÔ∏è The Algorithm: Backtracking with Optimizations</h2>

        <h3>Core Concept</h3>
        <p>We use <strong>Backtracking</strong> - a depth-first search algorithm that tries all possibilities and "backtracks" when it hits a dead end. Think of it like solving a maze: you try one path, and if it leads to a dead end, you go back to the last decision point and try a different path.</p>

        <div class="highlight">
            <strong>Why Backtracking?</strong> This is an exact cover problem - we need to cover exactly all cells except two (the month and date). 
            Backtracking systematically explores the solution space while pruning invalid branches early. It's like trying every possible combination of piece placements, but smart enough to give up on bad paths quickly.
        </div>

        <div class="visual-demo">
            <h4>Backtracking Visualization: Decision Tree</h4>
            <div style="color: #e0e0e0; font-family: monospace; font-size: 0.9em; line-height: 1.8; text-align: left; max-width: 700px; margin: 0 auto;">
                <div style="color: #00d2ff;">Start: Empty Board</div>
                <div style="margin-left: 20px;">‚îÇ</div>
                <div style="margin-left: 20px;">‚îú‚îÄ Try Piece 1 at (0,0) ‚úì</div>
                <div style="margin-left: 40px;">‚îÇ  ‚îú‚îÄ Try Piece 2 at (0,3) ‚úì</div>
                <div style="margin-left: 60px;">‚îÇ  ‚îÇ  ‚îú‚îÄ Try Piece 3 at (1,0) ‚úó <span style="color: #ff4757;">(Collision!)</span></div>
                <div style="margin-left: 60px;">‚îÇ  ‚îÇ  ‚îú‚îÄ Try Piece 3 at (1,1) ‚úó <span style="color: #ff4757;">(Collision!)</span></div>
                <div style="margin-left: 60px;">‚îÇ  ‚îÇ  ‚îî‚îÄ Try Piece 3 at (2,0) ‚úì</div>
                <div style="margin-left: 80px;">‚îÇ  ‚îÇ     ‚îî‚îÄ Try Piece 4... <span style="color: #2ed573;">(Continue...)</span></div>
                <div style="margin-left: 40px;">‚îÇ  ‚îî‚îÄ Try Piece 2 at (0,4) ‚úì</div>
                <div style="margin-left: 60px;">‚îÇ     ‚îî‚îÄ Try Piece 3 at (1,0) ‚úì</div>
                <div style="margin-left: 40px;">‚îÇ</div>
                <div style="margin-left: 20px;">‚îú‚îÄ Try Piece 1 at (0,1) ‚úó <span style="color: #ff4757;">(Out of bounds!)</span></div>
                <div style="margin-left: 20px;">‚îî‚îÄ Try Piece 1 at (1,0) ‚úì</div>
                <div style="margin-left: 40px;">   ‚îî‚îÄ Try Piece 2... <span style="color: #2ed573;">(Explore...)</span></div>
            </div>
            <p style="color: #aaa; font-size: 0.9em; margin-top: 20px; text-align: center;">Each branch represents a placement choice. Red ‚úó means we backtrack and try the next option.</p>
        </div>

        <div class="explanation-box">
            <p><strong>Key Insight:</strong> When we hit a dead end (can't place any more pieces), we don't give up entirely. We "undo" the last placement and try a different position. This is the "backtracking" part.</p>
            <p><strong>Pruning:</strong> If a placement is invalid (fails boundary, null, or collision check), we don't even explore that branch. This saves millions of unnecessary checks!</p>
        </div>

        <h3>Algorithm Steps</h3>
        <p><span class="step-number">1</span> <strong>Base Case:</strong> If all pieces are placed, we found a solution!</p>
        <pre><code class="language-javascript">if (usedMask === ALL_PIECES_MASK) {
    solutions.push(gridCopy);
    return;
}</code></pre>

        <p><span class="step-number">2</span> <strong>Select Next Piece:</strong> Find the first unused piece using bitmask</p>
        <pre><code class="language-javascript">let pieceIndex = 0;
while (usedMask & (1 << pieceIndex)) {
    pieceIndex++;  // Skip used pieces
}</code></pre>

        <p><span class="step-number">3</span> <strong>Try All Orientations:</strong> For each rotation/flip of the piece</p>
        <pre><code class="language-javascript">for (let shape of transformedPieces[pieceIndex]) {
    // Try placing this orientation...
}</code></pre>

        <p><span class="step-number">4</span> <strong>Try All Positions:</strong> For each cell on the board</p>
        <pre><code class="language-javascript">for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
        if (canPlace(grid, shape, r, c)) {
            // Place piece and recurse
        }
    }
}</code></pre>

        <p><span class="step-number">5</span> <strong>Recursive Call:</strong> Try to place remaining pieces</p>
        <pre><code class="language-javascript">place(grid, shape, r, c, pieceIndex + 1);
const newUsedMask = usedMask | (1 << pieceIndex);
solve(grid, newUsedMask, solutions);
remove(grid, shape, r, c);  // Backtrack!</code></pre>

        <!-- Key Optimizations -->
        <h2>‚ö° Key Optimizations</h2>

        <h3>1. Pre-compute All Transformations</h3>
        <pre><code class="language-javascript">// Generate 8 orientations (4 rotations √ó 2 flips) once
const transformedPieces = rawPieces.map(piece => {
    return getTransforms(piece);  // Returns all valid orientations
});</code></pre>

        <h3>2. Early Termination</h3>
        <pre><code class="language-javascript">if (solutions.length >= MAX_SOLUTIONS) return;  // Stop at 10 solutions</code></pre>

        <h3>3. Bitmask Instead of Array</h3>
        <p>Using integer bitmasks is <strong>10x faster</strong> than boolean arrays for checking/updating piece usage.</p>

        <h3>4. Web Workers (Concurrency)</h3>
        <p>Run the heavy computation in a background thread so the UI doesn't freeze:</p>
        <pre><code class="language-javascript">const worker = new Worker('calendar-puzzle-worker.js');
worker.postMessage({ month, day });
worker.onmessage = (e) => { /* Update UI */ };</code></pre>

        <!-- Complexity Analysis -->
        <h2>üìä Complexity Analysis</h2>

        <div class="complexity-box">
            <h4>Time Complexity:</h4>
            <p><strong>O(8! √ó k √ó 43 √ó o)</strong> in worst case</p>
            <ul>
                <li><strong>8!</strong> = Ways to order 8 pieces (~40,000)</li>
                <li><strong>k</strong> = Average branching factor (~8 orientations)</li>
                <li><strong>43</strong> = Number of valid board cells</li>
                <li><strong>o</strong> = Overlap checks per placement</li>
            </ul>
            <p><strong>Practical:</strong> ~0.5-5 seconds on modern hardware (with optimizations)</p>
        </div>

        <div class="complexity-box">
            <h4>Space Complexity:</h4>
            <p><strong>O(n √ó m)</strong> for grid + <strong>O(d)</strong> for recursion depth</p>
            <ul>
                <li><strong>n √ó m</strong> = Grid size (7 √ó 7 = 49)</li>
                <li><strong>d</strong> = Recursion depth (at most 8 pieces deep)</li>
            </ul>
            <p><strong>Total:</strong> Very minimal memory usage!</p>
        </div>

        <!-- Why No Memoization -->
        <h2>ü§î Why No Memoization?</h2>
        <p>You might wonder: "Why not use Dynamic Programming?"</p>
        
        <div class="highlight">
            <strong>Answer:</strong> We benchmarked it! For finding just 10 solutions, the overhead of serializing 
            and storing states was <strong>slower</strong> than pure backtracking. Memoization helps when you need to 
            find ALL solutions, but for limited solutions, it adds unnecessary complexity.
        </div>

        <!-- Piece Transformations -->
        <h2>üîÑ How Piece Transformations Work</h2>
        
        <p>Each puzzle piece can be rotated and flipped to create different orientations. Understanding how coordinates transform is crucial for the solver to try all possibilities.</p>

        <h3>Rotation (90¬∞ clockwise)</h3>
        <p>When we rotate a shape 90¬∞ clockwise, each coordinate (row, col) transforms to (col, -row). This is a standard 2D rotation formula derived from rotation matrices in linear algebra.</p>

        <div class="visual-demo">
            <h4>Why (r, c) ‚Üí (c, -r)? The Math Behind It</h4>
            <div style="text-align: center; color: #e0e0e0; font-family: monospace;">
                <div style="max-width: 600px; margin: 0 auto; text-align: left;">
                    <p style="color: #00d2ff; font-size: 1.1em; margin-bottom: 15px;">Imagine a coordinate grid:</p>
                    <pre style="background: #1a1a1a; padding: 20px; line-height: 1.8;">
     c (columns) ‚Üí
r    0   1   2   3
‚Üì    
0    ‚Ä¢   ‚Ä¢   ‚Ä¢   ‚Ä¢
1    ‚Ä¢   ‚ñà   ‚Ä¢   ‚Ä¢    ‚Üê Point at (1, 1)
2    ‚Ä¢   ‚Ä¢   ‚Ä¢   ‚Ä¢
3    ‚Ä¢   ‚Ä¢   ‚Ä¢   ‚Ä¢
</pre>
                    <p style="color: #aaa; margin: 15px 0;">When we rotate 90¬∞ <strong>clockwise</strong>:</p>
                    <pre style="background: #1a1a1a; padding: 20px; line-height: 1.8;">
     c (columns) ‚Üí
r    0   1   2   3
‚Üì    
0    ‚Ä¢   ‚Ä¢   ‚Ä¢   ‚Ä¢
1    ‚Ä¢   ‚Ä¢   ‚ñà   ‚Ä¢    ‚Üê Point now at (1, 2)
2    ‚Ä¢   ‚Ä¢   ‚Ä¢   ‚Ä¢
3    ‚Ä¢   ‚Ä¢   ‚Ä¢   ‚Ä¢

Original: (row=1, col=1)
After:    (row=1, col=2) = (old_col, ???)
</pre>
                    <p style="color: #2ed573; font-size: 1.1em; margin: 15px 0;"><strong>Notice:</strong> new_col increases as old_row <strong>decreases</strong></p>
                    <p style="color: #00d2ff;">That's why we need <strong>-row</strong> (the negative flips the direction)</p>
                </div>
            </div>
        </div>

        <div class="explanation-box">
            <p><strong>The Formula: (r, c) ‚Üí (c, -r)</strong></p>
            <p><strong>Why "c" for new row?</strong> A point that was far to the right (high column) moves to the bottom (high row)</p>
            <p><strong>Why "-r" for new column?</strong> A point that was at the top (low row) moves to the right (high column). The negative flips the direction!</p>
            <p><strong>Example:</strong> Point (2, 1) means row 2, column 1</p>
            <ul style="margin-left: 20px; color: #e0e0e0;">
                <li>After rotation: (1, -2) = (col=1 becomes new_row, -row=-2 becomes new_col)</li>
                <li>But wait... negative column? That's where normalization comes in!</li>
            </ul>
        </div>
        
        <pre><code class="language-javascript">function rotate(shape) {
    // Transform: (row, col) ‚Üí (col, -row)
    return shape.map(([r, c]) => [c, -r]);
}

// Example with actual numbers - SEE THE NEGATIVES!
const piece = [[0,0], [1,0], [2,0]];  // Vertical line

const rotated = rotate(piece);
console.log(rotated);
// Output: [[0,0], [0,-1], [0,-2]]  ‚Üê NEGATIVE COLUMNS!
//                    ‚Üë      ‚Üë
//         These negatives come from -row

// That's why we MUST normalize next!</code></pre>

        <div class="visual-demo">
            <h4>Step-by-Step: Rotation Creates Negatives</h4>
            <div style="text-align: center;">
                <div class="grid-visual">
                    <h5>Original Piece</h5>
                    <div class="mini-grid" style="grid-template-columns: repeat(3, 35px);">
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                    </div>
                    <p style="color: #aaa; font-size: 0.85em; margin-top: 10px;">[[0,0], [1,0], [2,0]]</p>
                </div>

                <span class="arrow">‚Üí</span>

                <div class="grid-visual">
                    <h5>After rotate()</h5>
                    <div style="color: #ff4757; font-weight: bold; margin-bottom: 10px;">HAS NEGATIVES!</div>
                    <div style="font-family: monospace; font-size: 0.9em; background: #1a1a1a; padding: 15px; border-radius: 8px; text-align: left;">
                        <div style="color: #00d2ff;">[[0, 0],</div>
                        <div style="color: #ff4757;"> [0, -1],  ‚Üê Negative!</div>
                        <div style="color: #ff4757;"> [0, -2]]  ‚Üê Negative!</div>
                    </div>
                    <p style="color: #aaa; font-size: 0.85em; margin-top: 10px;">Can't use negatives on board!</p>
                </div>

                <span class="arrow">‚Üí</span>

                <div class="grid-visual">
                    <h5>After normalize()</h5>
                    <div style="color: #2ed573; font-weight: bold; margin-bottom: 10px;">NO NEGATIVES!</div>
                    <div class="mini-grid" style="grid-template-columns: repeat(3, 35px);">
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                    </div>
                    <p style="color: #aaa; font-size: 0.85em; margin-top: 10px;">[[0,0], [0,1], [0,2]]</p>
                    <p style="color: #2ed573; font-size: 0.9em;">Shifted by +2 in columns!</p>
                </div>
            </div>
        </div>

        <div class="explanation-box">
            <p><strong>Why You Don't See Negatives in Final Output:</strong></p>
            <p>1Ô∏è‚É£ <strong>rotate()</strong> creates negative coordinates (from the -r in formula)</p>
            <p>2Ô∏è‚É£ <strong>normalize()</strong> immediately shifts everything to remove negatives</p>
            <p>3Ô∏è‚É£ The final shape always starts at (0, 0) with no negative values</p>
            <p><strong>Analogy:</strong> It's like taking a photo of a rotated object, then cropping it so the object starts at the top-left corner. The negatives are temporary!</p>
        </div>

        <div class="visual-demo">
            <h4>Visual Example: Rotating an L-Piece</h4>
            <div style="text-align: center;">
                <div class="grid-visual">
                    <h5>Original (0¬∞)</h5>
                    <div class="mini-grid" style="grid-template-columns: repeat(3, 35px);">
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                    </div>
                    <p style="color: #aaa; font-size: 0.9em; margin-top: 10px;">[[0,0], [1,0], [2,0], [2,1], [2,2]]</p>
                </div>

                <span class="arrow">‚Üí</span>

                <div class="grid-visual">
                    <h5>Rotated 90¬∞</h5>
                    <div class="mini-grid" style="grid-template-columns: repeat(3, 35px);">
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                    </div>
                    <p style="color: #aaa; font-size: 0.9em; margin-top: 10px;">After rotation & normalization</p>
                </div>

                <span class="arrow">‚Üí</span>

                <div class="grid-visual">
                    <h5>Rotated 180¬∞</h5>
                    <div class="mini-grid" style="grid-template-columns: repeat(3, 35px);">
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                    </div>
                    <p style="color: #aaa; font-size: 0.9em; margin-top: 10px;">After 2 rotations</p>
                </div>

                <span class="arrow">‚Üí</span>

                <div class="grid-visual">
                    <h5>Rotated 270¬∞</h5>
                    <div class="mini-grid" style="grid-template-columns: repeat(3, 35px);">
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                    </div>
                    <p style="color: #aaa; font-size: 0.9em; margin-top: 10px;">After 3 rotations</p>
                </div>
            </div>
        </div>

        <div class="explanation-box">
            <p><strong>Why Rotation Matters:</strong> Each piece can appear in 4 different rotations. Some pieces look the same after certain rotations (symmetry), so we use a Set to store only unique orientations.</p>
            <p><strong>The Math:</strong> The formula (r, c) ‚Üí (c, -r) comes from 2D rotation matrices. The negative sign flips the row to rotate clockwise instead of counter-clockwise.</p>
        </div>

        <h3>Normalization (Move to origin)</h3>
        <p>After rotation, coordinates might be negative or far from (0,0). Normalization shifts all coordinates so the top-left piece starts at (0,0). This makes placement checking easier and ensures we can compare shapes properly.</p>
        
        <pre><code class="language-javascript">function normalize(shape) {
    const minR = Math.min(...shape.map(p => p[0]));
    const minC = Math.min(...shape.map(p => p[1]));
    return shape.map(([r, c]) => [r - minR, c - minC]);
}

// Example: After rotation we might have negative coords
// Before:  [[0,-2], [0,-1], [0,0], [1,0], [2,0]]
// After:   [[0,0], [0,1], [0,2], [1,2], [2,2]]  ‚Üê Shifted to origin</code></pre>

        <div class="visual-demo">
            <h4>Normalization Example</h4>
            <div style="text-align: center;">
                <div class="grid-visual">
                    <h5>After Rotation (Negative Coords)</h5>
                    <div class="mini-grid" style="grid-template-columns: repeat(5, 35px);">
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                    </div>
                    <p style="color: #aaa; font-size: 0.9em; margin-top: 10px;">Has negative coordinates!</p>
                </div>

                <span class="arrow">‚Üí</span>

                <div class="grid-visual">
                    <h5>After Normalization</h5>
                    <div class="mini-grid" style="grid-template-columns: repeat(3, 35px);">
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                    </div>
                    <p style="color: #aaa; font-size: 0.9em; margin-top: 10px;">Starts at (0,0) ‚úì</p>
                </div>
            </div>
        </div>

        <div class="explanation-box">
            <p><strong>Why Normalize:</strong> Without normalization, we'd have pieces with negative coordinates or coordinates that don't start at (0,0). This makes it impossible to place them on the board correctly.</p>
            <p><strong>How It Works:</strong> Find the minimum row and column values, then subtract them from all coordinates. This shifts everything to start at (0,0).</p>
        </div>

        <h3>Generating All Orientations</h3>
        <p>We combine rotation and flipping to generate up to 8 unique orientations per piece. Some pieces have symmetry, so they might have fewer than 8 unique forms.</p>
        
        <pre><code class="language-javascript">function getTransforms(shape) {
    const forms = new Set();  // Set automatically removes duplicates
    let s = shape;
    
    for (let i = 0; i < 4; i++) {
        s = rotate(s);  // 4 rotations (0¬∞, 90¬∞, 180¬∞, 270¬∞)
        forms.add(JSON.stringify(normalize(s)));
        
        const flipped = s.map(([r,c]) => [r, -c]);  // Mirror flip
        forms.add(JSON.stringify(normalize(flipped)));
    }
    
    return [...forms].map(f => JSON.parse(f));
}

// Result: Array of all unique orientations for this piece
// Symmetric pieces will have fewer than 8 (duplicates removed by Set)</code></pre>

        <div class="explanation-box">
            <p><strong>4 Rotations √ó 2 Flips = 8 Possible Orientations</strong></p>
            <p><strong>Why Use a Set:</strong> Some shapes look identical after certain transformations (like a square looks the same after 90¬∞ rotation). The Set automatically removes these duplicates.</p>
            <p><strong>Performance:</strong> Pre-computing all orientations once is much faster than computing them during the recursive backtracking process.</p>
        </div>

        <!-- Placement Logic -->
        <h2>üéØ Placement Validation</h2>
        <p>Before placing a piece on the board, we must verify three critical conditions. Each condition prevents different types of invalid placements. Let's explore each check in detail with visual examples.</p>
        
        <h3>The Three Validation Rules</h3>
        
        <pre><code class="language-javascript">function canPlace(grid, shape, r, c) {
    for (let [dr, dc] of shape) {
        const nr = r + dr;  // New row position
        const nc = c + dc;  // New column position
        
        // 1. Stay within bounds (don't fall off the board!)
        if (nr < 0 || nr >= 7 || nc < 0 || nc >= 7) return false;
        
        // 2. Must be a real board cell (not cut-out corner)
        if (boardLayout[nr][nc] === null) return false;
        
        // 3. Cell must be empty (no collision with other pieces or target)
        if (grid[nr][nc] !== 0) return false;
    }
    return true;  // All checks passed!
}</code></pre>

        <h3>Rule 1: Boundary Checking (Stay Within 7√ó7 Grid)</h3>
        <p>The board is a 7√ó7 grid with coordinates from (0,0) to (6,6). If any part of a piece tries to go outside these bounds, the placement is invalid.</p>

        <div class="visual-demo">
            <h4>Example: Piece Goes Out of Bounds</h4>
            <div style="text-align: center;">
                <div class="grid-visual">
                    <h5>‚ùå Invalid Placement</h5>
                    <div class="mini-grid" style="grid-template-columns: repeat(7, 35px);">
                        <div class="mini-cell empty" style="opacity: 0.3;">0</div>
                        <div class="mini-cell empty" style="opacity: 0.3;">1</div>
                        <div class="mini-cell empty" style="opacity: 0.3;">2</div>
                        <div class="mini-cell empty" style="opacity: 0.3;">3</div>
                        <div class="mini-cell empty" style="opacity: 0.3;">4</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell invalid">?</div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell invalid">?</div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell invalid">?</div>
                    </div>
                    <p style="color: #ff4757; font-size: 0.9em; margin-top: 10px;">Piece extends beyond col 6!</p>
                    <p style="color: #aaa; font-size: 0.85em;">nc = 7 ‚Üí Out of bounds</p>
                </div>

                <span class="arrow" style="color: #2ed573;">‚úì</span>

                <div class="grid-visual">
                    <h5>‚úÖ Valid Placement</h5>
                    <div class="mini-grid" style="grid-template-columns: repeat(7, 35px);">
                        <div class="mini-cell empty" style="opacity: 0.3;">0</div>
                        <div class="mini-cell empty" style="opacity: 0.3;">1</div>
                        <div class="mini-cell empty" style="opacity: 0.3;">2</div>
                        <div class="mini-cell empty" style="opacity: 0.3;">3</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty" style="opacity: 0.3;">6</div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty" style="opacity: 0.3;"></div>
                    </div>
                    <p style="color: #2ed573; font-size: 0.9em; margin-top: 10px;">All cells within bounds!</p>
                    <p style="color: #aaa; font-size: 0.85em;">All nc values: 4, 5 ‚Üí Valid</p>
                </div>
            </div>
        </div>

        <div class="explanation-box">
            <p><strong>Boundary Check Logic:</strong></p>
            <p><strong>if (nr < 0 || nr >= 7)</strong> ‚Üí Row is negative or too large (falls off top/bottom)</p>
            <p><strong>if (nc < 0 || nc >= 7)</strong> ‚Üí Column is negative or too large (falls off left/right)</p>
            <p><strong>Why This Matters:</strong> Without this check, we'd try to access array indices that don't exist, causing crashes or undefined behavior.</p>
        </div>

        <h3>Rule 2: Null Cell Checking (Avoid Cut-Out Corners)</h3>
        <p>The calendar board has two cut-out corners (top-right and bottom-right) that are marked as <code>null</code> in our board layout. Pieces cannot be placed on these positions.</p>

        <div class="visual-demo">
            <h4>Example: Piece Tries to Use Null Cell</h4>
            <div style="text-align: center;">
                <div class="grid-visual">
                    <h5>Board Layout</h5>
                    <div class="mini-grid" style="grid-template-columns: repeat(7, 35px);">
                        <div class="mini-cell" style="background: #4a4a4a; color: #ccc; font-size: 9px;">JAN</div>
                        <div class="mini-cell" style="background: #4a4a4a; color: #ccc; font-size: 9px;">FEB</div>
                        <div class="mini-cell" style="background: #4a4a4a; color: #ccc; font-size: 9px;">MAR</div>
                        <div class="mini-cell" style="background: #4a4a4a; color: #ccc; font-size: 9px;">APR</div>
                        <div class="mini-cell" style="background: #4a4a4a; color: #ccc; font-size: 9px;">MAY</div>
                        <div class="mini-cell" style="background: #4a4a4a; color: #ccc; font-size: 9px;">JUN</div>
                        <div class="mini-cell" style="background: #1a1a1a; color: #ff4757;">‚úó</div>
                        <div class="mini-cell" style="background: #4a4a4a; color: #ccc; font-size: 9px;">JUL</div>
                        <div class="mini-cell" style="background: #4a4a4a; color: #ccc; font-size: 9px;">AUG</div>
                        <div class="mini-cell" style="background: #4a4a4a; color: #ccc; font-size: 9px;">SEP</div>
                        <div class="mini-cell" style="background: #4a4a4a; color: #ccc; font-size: 9px;">OCT</div>
                        <div class="mini-cell" style="background: #4a4a4a; color: #ccc; font-size: 9px;">NOV</div>
                        <div class="mini-cell" style="background: #4a4a4a; color: #ccc; font-size: 9px;">DEC</div>
                        <div class="mini-cell" style="background: #1a1a1a; color: #ff4757;">‚úó</div>
                    </div>
                    <p style="color: #ff4757; font-size: 0.9em; margin-top: 10px;">‚úó = null cells (don't exist)</p>
                </div>

                <div class="grid-visual">
                    <h5>‚ùå Invalid: Piece on Null</h5>
                    <div class="mini-grid" style="grid-template-columns: repeat(7, 35px);">
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell invalid">‚úó</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell invalid">‚úó</div>
                    </div>
                    <p style="color: #ff4757; font-size: 0.9em; margin-top: 10px;">Piece touches null cell!</p>
                </div>

                <div class="grid-visual">
                    <h5>‚úÖ Valid: Avoids Null</h5>
                    <div class="mini-grid" style="grid-template-columns: repeat(7, 35px);">
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell" style="background: #1a1a1a;"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty"></div>
                        <div class="mini-cell" style="background: #1a1a1a;"></div>
                    </div>
                    <p style="color: #2ed573; font-size: 0.9em; margin-top: 10px;">Stays in valid area!</p>
                </div>
            </div>
        </div>

        <div class="explanation-box">
            <p><strong>Null Check Logic:</strong></p>
            <p><strong>if (boardLayout[nr][nc] === null)</strong> ‚Üí This cell doesn't exist on the physical board</p>
            <p><strong>Why This Matters:</strong> The calendar puzzle has an irregular shape. We can't place pieces in areas that don't physically exist on the wooden board.</p>
        </div>

        <h3>Rule 3: Collision Detection (No Overlapping)</h3>
        <p>Each cell can only contain one piece at a time. We must check that the target cell is empty (value = 0) before placing a piece there. Non-zero values mean the cell is occupied by another piece or is a target date.</p>

        <div class="visual-demo">
            <h4>Example: Piece Collision</h4>
            <div style="text-align: center;">
                <div class="grid-visual">
                    <h5>Current Board State</h5>
                    <div class="mini-grid" style="grid-template-columns: repeat(5, 35px);">
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell" style="background: #9b59b6; color: white;">2</div>
                        <div class="mini-cell" style="background: #9b59b6; color: white;">2</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell" style="background: #9b59b6; color: white;">2</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell" style="background: #e74c3c; color: white;">-1</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell empty">0</div>
                    </div>
                    <p style="color: #aaa; font-size: 0.85em; margin-top: 10px;">Purple = Piece 2, Red = Target</p>
                </div>

                <div class="grid-visual">
                    <h5>‚ùå Collision!</h5>
                    <div class="mini-grid" style="grid-template-columns: repeat(5, 35px);">
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell invalid">‚úó</div>
                        <div class="mini-cell" style="background: #9b59b6; color: white;">2</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell invalid">‚úó</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell invalid">‚úó</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell empty">0</div>
                    </div>
                    <p style="color: #ff4757; font-size: 0.9em; margin-top: 10px;">Overlaps existing piece & target!</p>
                </div>

                <div class="grid-visual">
                    <h5>‚úÖ No Collision</h5>
                    <div class="mini-grid" style="grid-template-columns: repeat(5, 35px);">
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell" style="background: #9b59b6; color: white;">2</div>
                        <div class="mini-cell" style="background: #9b59b6; color: white;">2</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell" style="background: #9b59b6; color: white;">2</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell piece">‚ñà</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell" style="background: #e74c3c; color: white;">-1</div>
                        <div class="mini-cell empty">0</div>
                        <div class="mini-cell empty">0</div>
                    </div>
                    <p style="color: #2ed573; font-size: 0.9em; margin-top: 10px;">All cells empty (value = 0)!</p>
                </div>
            </div>
        </div>

        <div class="explanation-box">
            <p><strong>Collision Check Logic:</strong></p>
            <p><strong>if (grid[nr][nc] !== 0)</strong> ‚Üí Cell is occupied</p>
            <p><strong>Grid Values:</strong></p>
            <ul style="margin-left: 20px; color: #e0e0e0;">
                <li><strong>0</strong> = Empty cell (can place here)</li>
                <li><strong>-1</strong> = Target date/month (must remain visible)</li>
                <li><strong>1-8</strong> = Piece ID (already occupied by that piece)</li>
            </ul>
            <p><strong>Why This Matters:</strong> Pieces cannot overlap each other or cover the target date. This check ensures physical validity of the solution.</p>
        </div>

        <h3>Putting It All Together: The Complete Check</h3>
        <p>When we try to place a piece at position (r, c), we iterate through every cell of that piece and verify all three conditions. If <strong>any</strong> cell fails <strong>any</strong> check, the entire placement is rejected.</p>

        <div class="explanation-box">
            <p><strong>Order of Checks Matters:</strong></p>
            <p>1Ô∏è‚É£ <strong>Boundary first:</strong> Prevents array index errors</p>
            <p>2Ô∏è‚É£ <strong>Null check second:</strong> Avoids checking properties of null</p>
            <p>3Ô∏è‚É£ <strong>Collision last:</strong> Only checks valid, existing cells</p>
            <p><strong>Performance Tip:</strong> We return <code>false</code> immediately on the first failure. No need to check remaining cells if one already failed!</p>
        </div>

        <!-- Real Code -->
        <h2>üíª View the Full Implementation</h2>
        <p>The complete solver implementation with all optimizations:</p>
        
        <a href="https://github.com/codesmith17/perpetual-calender/blob/main/puzzle-core.js" 
           target="_blank" 
           class="github-link">
            üìÇ View puzzle-core.js on GitHub ‚Üí
        </a>

        <!-- Summary -->
        <h2>‚ú® Summary</h2>
        <ul>
            <li><strong>Algorithm:</strong> Backtracking (DFS with pruning)</li>
            <li><strong>Data Structures:</strong> 2D arrays, bitmasks, coordinate lists</li>
            <li><strong>Optimizations:</strong> Pre-computed transformations, early termination, bit operations, Web Workers</li>
            <li><strong>Time:</strong> ~0.5-5 seconds for 10 solutions</li>
            <li><strong>Space:</strong> O(49 + 8) = O(1) constant space</li>
        </ul>

        <div class="highlight">
            <strong>Key Insight:</strong> Sometimes the "simple" algorithm (backtracking) beats the "clever" one (memoization) 
            when you tune it for the specific problem constraints!
        </div>

        <br><br>
        <a href="../" class="back-btn">‚Üê Back to Puzzle</a>
    </div>

    <script>
        // Initialize syntax highlighting
        hljs.highlightAll();
    </script>
</body>
</html>
